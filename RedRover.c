#pragma config(Motor,  port1,           Claw1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftF,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LeftB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightF,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightB,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Cannon1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Cannon2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Claw2,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


/*Read Me:
	Literally only used for autonomous testing
	Make sure to copy all changes from BotCoin.c's autonomous into here
	also CHANGE if we can get some enconders because wait statements are inconsistent
*/
task main()
{
	//change direction in accordance with notebook (1-6)
resetMotorEncoder(LeftF);
resetMotorEncoder(LeftB);
resetMotorEncoder(RightF);
resetMotorEncoder(RightB);
int direction = 1;
int encVal = 1000;
//Use encoder Values from other file
//REMOVE THIS WAIT STATE FOR COMPETITION IT IS ONLY TO GET HANDS OUT OF THE WAY
wait1Msec(1000);
if(direction == 1){
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to middle
	while(getMotorEncoder(RightF) < encVal){		//i don't know what to divide encVal by.
		motor[LeftF]=motor[LeftB]=-127;			//find the angle needed to turn from flag facing to middle facing
		motor[RightF]=motor[RightB]=127;
	}
	//moves to platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 1000){		//unrelated to encVal. Just find a value that works
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/4){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//moves onto platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 750){	
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==2){		//any problems from direction=1 applies here (but in reverse for turning)
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to middle
	while(getMotorEncoder(LeftF) < encVal){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	}
	//moves to platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < 1500){	
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	while(getMotorEncoder(LeftF) < encVal/4){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	}
	//moves onto platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < 750){	
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==3){
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to cap
	while(getMotorEncoder(RightF) < encVal){
	motor[LeftF]=motor[LeftB]=-127;
	motor[RightF]=motor[RightB]=127;
	}
	//go to cap
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1000);
	//lower arm 
	motor[Arm]=-63;
	wait1Msec(500);
	//move under cap
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 500){
	motor[LeftF]=motor[LeftB]=63;
	motor[RightF]=motor[RightB]=63;
	}
	//raise arm to flip cap
	motor[Arm]=127;
	wait1Msec(750);
	//I have no clue how to flip the cap
	//turn to plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/8){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//move onto plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 1000){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==4){
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to cap
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(250);
	//go to cap
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1000);
	//lower arm maybe and grab cap
	motor[Arm]=-63;
	wait1Msec(500);
	
	//I have no clue how to flip the cap
	//turn to plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}
else if(direction==5){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
	//I don't know how to flip the diagnol cap but Zach said the claw could do it
	//turn to platform
	motor[LeftF]=motor[LeftB]=-127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}
else if(direction==6){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
	//I don't know how to flip the diagnol cap but Zach said the claw could do it
	//turn to platform
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}

else{		//to account for user error in inputing the variable
	motor[LeftF]=motor[LeftB]=-127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(5000);
}
}
