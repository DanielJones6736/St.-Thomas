#pragma config(Motor,  port1,           Claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftF,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LeftB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightF,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightB,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Cannon,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           Cannon2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          Claw2,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
        // All activities that occur before the competition starts
        // Example: clearing encoders, setting servo positions, ...
resetMotorEncoder(LeftF);
resetMotorEncoder(LeftB);
resetMotorEncoder(RightF);
resetMotorEncoder(RightB);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Use command for no auton   AuonomousCodePlaceholderForTesting();
  // .....................................................................................

//change direction in accordance with notebook (1-6) 7-8 are just cap flipping



// type below /*


int direction = 7;
int encVal = 1000;
//Use encoder Values from other file
if(direction == 1){
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to middle
	while(getMotorEncoder(RightF) < encVal){		//i don't know what to divide encVal by.
		motor[LeftF]=motor[LeftB]=-127;			//find the angle needed to turn from flag facing to middle facing
		motor[RightF]=motor[RightB]=127;
	}
	//moves to platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 1000){		//unrelated to encVal. Just find a value that works
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/4){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//moves onto platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 750){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==2){		//any problems from direction=1 applies here (but in reverse for turning)
	motor[Cannon]=127;
  wait1Msec(750);
	//turn to middle
	while(getMotorEncoder(LeftF) < encVal){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	}
	//moves to platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < 1500){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	while(getMotorEncoder(LeftF) < encVal/4){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	}
	//moves onto platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < 750){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==3){
	motor[Cannon]=127;
	wait1Msec(750);
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/8){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//go to cap
	while(getMotorEncoder(LeftF) < 1500){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//lower arm
	motor[Arm]=-63;
	wait1Msec(500);
	//move under cap
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 500){
		motor[LeftF]=motor[LeftB]=63;
		motor[RightF]=motor[RightB]=63;
	}
	//raise arm to flip cap
	motor[Arm]=127;
	wait1Msec(750);
	//turn to plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/4){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//move towards plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/4){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//turn to mid plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/8){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//move onto plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 1000){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	}
}
else if(direction==4){
	motor[Cannon]=127;
	wait1Msec(750);
	//turn to cap
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(250);
	//go to cap
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1000);
	//lower arm maybe and grab cap
	motor[Arm]=-63;
	wait1Msec(500);

	//I have no clue how to flip the cap
	//turn to plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}
else if(direction==5){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
	//I don't know how to flip the diagnol cap but Zach said the claw could do it
	//turn to platform
	motor[LeftF]=motor[LeftB]=-127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}
else if(direction==6){
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
	//I don't know how to flip the diagnol cap but Zach said the claw could do it
	//turn to platform
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=-127;
	wait1Msec(1000);
	//move onto plat
	motor[LeftF]=motor[LeftB]=127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(1350);
}
//*******************************************************************
else if(direction==7){
	//go to cap
	while(getMotorEncoder(LeftF) < 1500){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//lower arm
	motor[Arm]=-63;
	wait1Msec(500);
	//move under cap
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 500){
		motor[LeftF]=motor[LeftB]=63;
		motor[RightF]=motor[RightB]=63;
	}
	//raise arm to flip cap
	motor[Arm]=127;
	wait1Msec(750);
	//turn to plat
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/4){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//moves to platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 1000){		//unrelated to encVal. Just find a value that works
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < encVal/8){
		motor[LeftF]=motor[LeftB]=-127;
		motor[RightF]=motor[RightB]=127;
	}
	//moves onto platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 750){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
//********************************
else if(direction==8){
	//go to cap
	while(getMotorEncoder(LeftF) < 1500){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//lower arm
	motor[Arm]=-63;
	wait1Msec(500);
	//move under cap
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 500){
		motor[LeftF]=motor[LeftB]=63;
		motor[RightF]=motor[RightB]=63;
	}
	//raise arm to flip cap
	motor[Arm]=127;
	wait1Msec(750);
	//turn to plat
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < encVal/4){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=-127;
	}
	//moves to platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < 1000){		//unrelated to encVal. Just find a value that works
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
	//turns to dead mid platform
	resetMotorEncoder(LeftF);
	while(getMotorEncoder(LeftF) < encVal/8){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=-127;
	}
	//moves onto platform
	resetMotorEncoder(RightF);
	while(getMotorEncoder(RightF) < 750){
		motor[LeftF]=motor[LeftB]=127;
		motor[RightF]=motor[RightB]=127;
	}
}
else{
	//to account for user error in inputing the variable
	motor[LeftF]=motor[LeftB]=-127;
	motor[RightF]=motor[RightB]=127;
	wait1Msec(5000);
}



// type */


}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
        // User control code here, inside the loop

        while (true)
        {
          // This is the main execution loop for the user control program. Each time through the loop
          // your program should update motor + servo values based on feedback from the joysticks.

          // .....................................................................................
          // Insert user code here. This is where you use the joystick values to update your motors, etc.
          // Use UserControlCodePlaceholderForTesting(); for no control
          // .....................................................................................

//Driver Controls Heck Ya BOI


int leftside=vexRT[Ch3];		//sets respective buttons or joysticks to a variable for easier to read code
int rightside=vexRT[Ch2];
int clawclose=vexRT[Btn6U];
int clawopen=vexRT[Btn6D];
int armup=vexRT[Btn5U];
int armdown=vexRT[Btn5D];

	  //creates "deadspace" to prevent motor burnout when joystick not pressed
	  //can be changed to lower numbers like 5 to give driver more control but don't go much lower

	  //Left controls
		if (leftside >= 10)
		{
			motor[LeftF]=leftside;
			motor[LeftB]=leftside;			//sets front and back motors on left to joystick input 10 to 127
		}
		else if (leftside <= -10)			//-127 to -10
		{
			motor[LeftF]=leftside;
			motor[LeftB]=leftside;
		}
		else			//if between -10 and 10 set motors to 0
		{
			motor[LeftF]=0;
			motor[LeftB]=0;
		}

		//Right controls
		if (rightside >= 10)		//same comments apply from above
		{
			motor[RightF]=rightside;
			motor[RightB]=rightside;
		}
		else if (rightside <= -10)
		{
			motor[RightF]=rightside;
			motor[RightB]=rightside;
		}
		else
		{
			motor[RightF]=0;
			motor[RightB]=0;
		}

		//claw stuff
		if (clawclose == 1)						//used for claw (probably the cap claw unless changed)
		{														//used to raise and lower the claw when respective buttons pressed down
			motor[Claw]=127;
		}
		else if (clawopen == 1)
		{
			motor[Claw]=-127;
		}
		else												//if both buttons pressed claw will go up due to order of if statements
		{
			motor[Claw]=0;				//due to gravity claw will go down but slowly (test different positive values to try to counteract gravity)
		}
		//I'll add the other stuff later
		//Arm controls
		if (armup == 1)		//same comments apply from above
		{
			motor[Arm]=127;
		}
		else if (armdown == 1)
		{
			motor[Arm]=-127;
		}
		else
		{
			motor[Arm]=0;
		}
	}
}

